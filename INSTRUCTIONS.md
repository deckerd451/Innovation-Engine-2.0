# Innovation Engine 2.0 - Supabase Backend Setup Guide

Congratulations on upgrading to a full-fledged Supabase backend! Follow these steps to get your application running with a real database and authentication.

## Step 1: Create a Supabase Project

1.  Go to [supabase.com](https://supabase.com/) and sign up or log in.
2.  Click on "New project" and give it a name (e.g., "InnovationEngine").
3.  Choose a region close to your users and create the project. Wait for it to be set up.

## Step 2: Get API Credentials

1.  In your Supabase project dashboard, navigate to the **Settings** (cog icon) in the left sidebar.
2.  Click on **API**.
3.  You will find your **Project URL** and your **Project API keys**. You need the `anon` `public` key.
4.  Keep this page open, you'll need these values in the next step.

## Step 3: Update `supabaseClient.ts`

1.  Open the `supabaseClient.ts` file in your project.
2.  Replace the placeholder values for `supabaseUrl` and `supabaseAnonKey` with the credentials you found in Step 2.

```typescript
// supabaseClient.ts

// BEFORE
const supabaseUrl = 'YOUR_SUPABASE_URL';
const supabaseAnonKey = 'YOUR_SUPABASE_ANON_KEY';

// AFTER
const supabaseUrl = 'https://xxxxxxxxxxxx.supabase.co'; // Your actual URL
const supabaseAnonKey = 'ey...'; // Your actual anon key
```

## Step 4: Set Up Database Schema & Security

This is the most important step. We will create the necessary tables and security rules (Row Level Security).

1.  In your Supabase project dashboard, go to the **SQL Editor** (SQL icon).
2.  Click "+ New query".
3.  Copy and paste the entire SQL script below into the editor and click **RUN**.

```sql
-- 1. PROFILES TABLE
-- This table stores public user data. It's linked to the auth.users table.
CREATE TABLE public.profiles (
  id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email text,
  full_name text,
  headline text,
  bio text,
  avatar_url text
);
-- Set up Row Level Security (RLS)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
-- Policy: Allow users to read all profiles
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
-- Policy: Allow users to update their own profile
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);


-- 2. SKILLS TABLE
-- Stores skills for each user.
CREATE TABLE public.skills (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  skill_name text NOT NULL,
  -- Ensure a user can't have the same skill twice
  UNIQUE(user_id, skill_name)
);
-- Set up RLS
ALTER TABLE public.skills ENABLE ROW LEVEL SECURITY;
-- Policy: Allow users to read all skills
CREATE POLICY "Skills are viewable by everyone." ON public.skills FOR SELECT USING (true);
-- Policy: Allow users to add skills for themselves
CREATE POLICY "Users can insert their own skills." ON public.skills FOR INSERT WITH CHECK (auth.uid() = user_id);


-- 3. ENDORSEMENTS TABLE
-- Tracks who endorsed which skill.
CREATE TABLE public.endorsements (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  skill_id bigint NOT NULL REFERENCES public.skills(id) ON DELETE CASCADE,
  endorser_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  -- A user can only endorse a specific skill once
  UNIQUE(skill_id, endorser_id)
);
-- Set up RLS
ALTER TABLE public.endorsements ENABLE ROW LEVEL SECURITY;
-- Policy: Allow users to read all endorsements
CREATE POLICY "Endorsements are viewable by everyone." ON public.endorsements FOR SELECT USING (true);
-- Policy: Allow users to add/remove their own endorsements
CREATE POLICY "Users can create or delete their own endorsements." ON public.endorsements FOR ALL USING (auth.uid() = endorser_id);


-- 4. CONNECTIONS TABLE
-- Stores bidirectional connections between users.
CREATE TABLE public.connections (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user1_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  user2_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  -- Prevent duplicate connections
  UNIQUE(user1_id, user2_id)
);
-- Set up RLS
ALTER TABLE public.connections ENABLE ROW LEVEL SECURITY;
-- Policy: Allow users to see all connections
CREATE POLICY "Connections are viewable by everyone." ON public.connections FOR SELECT USING (true);
-- Policy: Allow users to add/remove connections involving themselves
CREATE POLICY "Users can manage their own connections." ON public.connections FOR ALL USING (auth.uid() = user1_id OR auth.uid() = user2_id);
```

## Step 5: Create Auth Trigger

This trigger will automatically create a new `profile` entry for every new user that signs up.

1.  Go back to the **SQL Editor**.
2.  Click "+ New query".
3.  Copy and paste the SQL script below and click **RUN**.

```sql
-- Function to create a profile for a new user
create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, full_name, avatar_url, email)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url', new.email);
  return new;
end;
$$;

-- Trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
```

## You're All Set!

Your application is now fully configured to work with a production-ready Supabase backend. You can now run the app, sign up for a new account, and all data will be saved to your Supabase project.

## (Optional) Deploying to GitHub Pages

1.  Make sure your code is pushed to a GitHub repository.
2.  In your repository, go to **Settings** > **Pages**.
3.  Under "Build and deployment", select the source as **Deploy from a branch**.
4.  Choose your main branch (e.g., `main`) and the `/ (root)` folder. Click **Save**.
5.  GitHub will build and deploy your site. It might take a few minutes. You'll find the public URL on the same page.
```